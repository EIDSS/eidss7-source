/*
Deployment script for EIDSS7_GG

This code was generated by a tool.
Changes to this file may cause incorrect behavior and will be lost if
the code is regenerated.
*/

GO
SET ANSI_NULLS, ANSI_PADDING, ANSI_WARNINGS, ARITHABORT, CONCAT_NULL_YIELDS_NULL, QUOTED_IDENTIFIER ON;

SET NUMERIC_ROUNDABORT OFF;


GO

USE [$(DatabaseName)];


GO
PRINT N'Altering Trigger [dbo].[TR_gisLocation_UpdateDenormalizedHierarchy]...';


GO

-- =============================================
-- Author:		Steven Verner
-- Create date: 1/4/2021
-- Description:	Rebuilds gisLocationDenormalized when:
	-- 1.  When a new location is inserted.
	-- 2.  When a location is re-parented (moved)
	-- 3.  When the location is deleted (intRowStatus = 1)
-- History:
--	Date		Developer			Comments
--	03/17/2022	Steven Verner		Fixed the issue where the incorrect level type was specified.
--  10/27/2022  Mani Govindarajan   LevelType - to  ISNULL(lt.strTextString,[level]) - Temp Fix
-- =============================================
ALTER TRIGGER [dbo].[TR_gisLocation_UpdateDenormalizedHierarchy]
   ON  [dbo].[gisLocation] 
   AFTER INSERT,DELETE,UPDATE
AS 
BEGIN
	SET NOCOUNT ON;

		DECLARE 
			@current INT, 
			@max INT, 
			@languageId BIGINT, 
			@hi HIERARCHYID 

		DECLARE @t TABLE(
			L1ID BIGINT, L2ID BIGINT, L3ID BIGINT, L4ID BIGINT, L5ID BIGINT, L6ID BIGINT, L7ID BIGINT,
			L1NAME NVARCHAR(255),L2NAME NVARCHAR(255),L3NAME NVARCHAR(255),L4NAME NVARCHAR(255),L5NAME NVARCHAR(255),L6NAME NVARCHAR(255),L7NAME NVARCHAR(255),
			Node HIERARCHYID, 
			[Level] INT,
			idfsLocation BIGINT,
			LanguageId BIGINT )
		
		DECLARE @Languages TABLE(id INT IDENTITY, idfsLanguage BIGINT)
		INSERT INTO @Languages(idfsLanguage)
		SELECT idfsLanguage
		FROM dbo.gisLocationDenormalized ld
		GROUP BY idfsLanguage 
		
		DECLARE @idfsLocation BIGINT = NULL,
			@newParent HIERARCHYID,
			@oldParent HIERARCHYID,
			@newDeleted BIT,
			@oldDeleted BIT

			-- The following use cases must be captured:
			-- 1.  When a new location is inserted.
			-- 2.  When a location is re-parented (moved)
			-- 3.  When the location is deleted (intRowStatus = 1)
			-- 4.  When the location name changes...  (This use case cannot be captured here; it must be captured on the trtBaseReference table trigger...

	IF EXISTS(SELECT * FROM inserted) AND EXISTS (SELECT * FROM deleted) -- This is an update
	BEGIN

		--	====================================================
		--  Test to see if the location moved...
		--	====================================================
		SELECT 
		 @idfsLocation = idfsLocation
		,@newDeleted = CASE WHEN intRowStatus=1 THEN 1 ELSE 0 END
		,@newParent = NODE.GetAncestor(1)
		FROM Inserted 

		SELECT @oldDeleted = intRowStatus,  @oldParent = Node.GetAncestor(1) 
		FROM DELETED

		-- We always remove all references of the location in the gislocationDenormalized table,
		-- then generate a new entry...
		-- This handles both when a record was deleted (intRowStatus=1) and the need to remove the existing recordsprior to generating a new one for reparenting...

		-- When the location has moved or the record is reactivated (intRowStatus = 0)...
		IF(@newParent != @oldParent) 
		BEGIN 
			DELETE FROM gisLocationDenormalized WHERE idfsLocation = @idfsLocation
			GOTO GenerateNewReference
		END ELSE IF( @newDeleted = 1 )
			DELETE FROM gisLocationDenormalized WHERE idfsLocation = @idfsLocation

		ELSE IF(@oldDeleted =1 and @newDeleted = 0 )
			BEGIN
				DELETE FROM gisLocationDenormalized WHERE idfsLocation = @idfsLocation
				GOTO GenerateNewReference
			END

		GOTO Fini
	END

	IF EXISTS (SELECT * FROM inserted) AND NOT EXISTS (SELECT * FROM deleted) -- This is an insert
	BEGIN
		-- New location was inserted...
		SELECT @idfsLocation = idfsLocation FROM inserted;
		GOTO GenerateNewReference
	END

	IF EXISTS (SELECT * FROM deleted) AND NOT EXISTS(SELECT * FROM inserted) -- this is a delete
	BEGIN
		-- Location was deleted...
		SELECT @idfsLocation = idfsLocation FROM deleted;
		DELETE FROM dbo.gisLocationDenormalized WHERE idfsLocation = @idfsLocation
	END

	GOTO Fini
	/*
	--	====================================================
	GenerateNewReference:
	--	====================================================
		SELECT @current = 1, @max= COUNT(*) FROM @Languages
		
		-- Select the node for the inserted/updated location...
		SELECT @hi = Node FROM gisLocation l WHERE l.idfsLocation = @idfsLocation

		-- iterate thru all the languages and insert the hierarchy record for each...
		WHILE (@current <= @max)
		BEGIN
			
			--	Select a language...
			SELECT @languageId = idfsLanguage FROM @Languages WHERE id = @current

			-- Perform the insert...
			-- 1st into table variable...
			INSERT INTO @t(
						 L1ID
						,L2ID
						,L3ID
						,L4ID
						,L5ID
						,L6ID
						,L7ID
						,L1NAME
						,L2NAME
						,L3NAME
						,L4NAME
						,L5NAME
						,L6NAME
						,L7NAME
						,Node
						,[Level]
						,idfsLocation
						,LanguageId)

			-- PIVOT!!!!!
			-- Flatten the hierarchy and insert into gisLocationDenormalized...
			SELECT 
				-- LevelIDs 1 thru 7...
				MAX(CASE WHEN [Level]=1 THEN idfsLocation END ),
				MAX(CASE WHEN [Level]=2 THEN idfsLocation END ),
				MAX(CASE WHEN [Level]=3 THEN idfsLocation END ),
				MAX(CASE WHEN [Level]=4 THEN idfsLocation END ),
				MAX(CASE WHEN [Level]=5 THEN idfsLocation END ),
				MAX(CASE WHEN [Level]=6 THEN idfsLocation END ),
				MAX(CASE WHEN [Level]=7 THEN idfsLocation END ),
				-- LevelNames 1 thru 7...
				MAX(CASE WHEN [Level]=1 THEN LevelName END ),
				MAX(CASE WHEN [Level]=2 THEN LevelName END ),
				MAX(CASE WHEN [Level]=3 THEN LevelName END ),
				MAX(CASE WHEN [Level]=4 THEN LevelName END ),
				MAX(CASE WHEN [Level]=5 THEN LevelName END ),
				MAX(CASE WHEN [Level]=6 THEN LevelName END ),
				MAX(CASE WHEN [Level]=7 THEN LevelName END ),
				-- Node...
				MAX(Node),
				MAX(level),
				MAX(idfsLocation),
				@languageId
			FROM 
				(
				SELECT 
					l.Node.GetLevel() [Level]
					,COALESCE(snt.strTextString, b.strDefault) [LevelName]
					,b.strDefault [LevelNameDefault]
					,idfsLocation
					,Node
					--,LevelType.strTextString
					 ,rn=ROW_NUMBER() OVER (PARTITION BY 0 ORDER BY node.GetLevel())
				FROM gisLocation l
				JOIN gisBaseReference b ON b.idfsGISBaseReference = l.idfsLocation
				LEFT JOIN dbo.gisStringNameTranslation snt ON snt.idfsGISBaseReference = l.idfsLocation AND 
					snt.idfsLanguage = dbo.FN_GBL_LanguageCode_GET(@languageId)
				WHERE @hi.IsDescendantOf(node) = 1
				) a

				-- Reset...
				SET @current = @current+1
				SELECT @languageId = NULL
		END
		
		-- Finally, insert into gis table...
		INSERT INTO dbo.gisLocationDenormalized
			(
				Level1ID, 
				Level2ID, 
				Level3ID, 
				Level4ID, 
				Level5ID, 
				Level6ID, 
				Level7ID,
				Level1Name,
				Level2Name, 
				Level3Name, 
				Level4Name, 
				Level5Name, 
				Level6Name, 
				Level7Name,
				Node,
				Level,
				idfsLocation,
				LevelType,
				idfsLanguage
			)
		SELECT  L1ID,L2ID,L3ID,L4ID,L5ID,L6ID,L7ID,
				L1NAME,L2NAME,L3NAME,L4NAME,L5NAME,L6NAME,L7NAME,
				node,[level],l.idfsLocation,lt.strTextString,l.LanguageId
		FROM @t l
		JOIN gisBaseReference b ON b.idfsGISBaseReference = l.idfsLocation
		JOIN gisReferenceType t ON t.idfsGISReferenceType = b.idfsGISReferenceType
		JOIN dbo.trtStringNameTranslation lt ON 
		lt.idfsLanguage = l.LanguageId AND lt.idfsBaseReference = 
		CASE l.Node.GetLevel() 
			WHEN 1 THEN 10003001 
			WHEN 2 THEN 10003003
			WHEN 3 THEN 10003002 
			WHEN 4 THEN 10003004 
			WHEN 5 THEN 0
			WHEN 6 THEN 0
			WHEN 7 THEN 0
		ELSE 0 END

		GOTO Fini
	*/
	--	====================================================
	GenerateNewReference:  
	--	====================================================

		SELECT @current = 1, @max= COUNT(*) FROM @Languages
		
		SELECT @hi = Node FROM gisLocation l WHERE l.idfsLocation = @idfsLocation

		-- iterate thru all the languages and insert the hierarchy record for each...
		WHILE (@current <= @max)
		BEGIN
			
			--	Select a language...
			SELECT @languageId = idfsLanguage FROM @Languages WHERE id = @current

			-- Perform the insert...
			-- 1st into table variable...
			INSERT INTO @t(
						 L1ID
						,L2ID
						,L3ID
						,L4ID
						,L5ID
						,L6ID
						,L7ID
						,L1NAME
						,L2NAME
						,L3NAME
						,L4NAME
						,L5NAME
						,L6NAME
						,L7NAME
						,Node
						,[Level]
						--,idfsLocation
						,LanguageId)

			-- PIVOT!!!!!
			-- Flatten the hierarchy and insert into gisLocationDenormalized...
			SELECT 
				-- LevelIDs 1 thru 7...
				MAX(CASE WHEN [Level]=1 THEN idfsLocation END ),
				MAX(CASE WHEN [Level]=2 THEN idfsLocation END ),
				MAX(CASE WHEN [Level]=3 THEN idfsLocation END ),
				MAX(CASE WHEN [Level]=4 THEN idfsLocation END ),
				MAX(CASE WHEN [Level]=5 THEN idfsLocation END ),
				MAX(CASE WHEN [Level]=6 THEN idfsLocation END ),
				MAX(CASE WHEN [Level]=7 THEN idfsLocation END ),
				-- LevelNames 1 thru 7...
				MAX(CASE WHEN [Level]=1 THEN LevelName END ),
				MAX(CASE WHEN [Level]=2 THEN LevelName END ),
				MAX(CASE WHEN [Level]=3 THEN LevelName END ),
				MAX(CASE WHEN [Level]=4 THEN LevelName END ),
				MAX(CASE WHEN [Level]=5 THEN LevelName END ),
				MAX(CASE WHEN [Level]=6 THEN LevelName END ),
				MAX(CASE WHEN [Level]=7 THEN LevelName END ),
				-- Node...
				MAX(Node),
				MAX(level),
				--MAX(idfsLocation),
				@languageId
			FROM 
				(
				SELECT 
					l.Node.GetLevel() [Level]
					,COALESCE(snt.strTextString, b.strDefault) [LevelName]
					,b.strDefault [LevelNameDefault]
					,idfsLocation
					,Node
					--,LevelType.strTextString
					 ,rn=ROW_NUMBER() OVER (PARTITION BY 0 ORDER BY node.GetLevel())
				FROM gisLocation l
				JOIN gisBaseReference b ON b.idfsGISBaseReference = l.idfsLocation
				LEFT JOIN dbo.gisStringNameTranslation snt ON snt.idfsGISBaseReference = l.idfsLocation AND 
					snt.idfsLanguage = dbo.FN_GBL_LanguageCode_GET(@languageId)
				WHERE @hi.IsDescendantOf(node) = 1
				) a

				-- Reset...
				SET @current = @current+1
				SELECT @languageId = NULL
		END

		-- Update the idfsLocation...
		UPDATE @t 
		SET idfsLocation = 
			CASE level WHEN 1 THEN L1ID
			WHEN 2 THEN L2ID
			WHEN 3 THEN L3ID
			WHEN 4 THEN L4ID
			WHEN 5 THEN L5ID 
			WHEN 6 THEN L6ID
			WHEN 7 THEN L7ID END
		
		-- Finally, insert into gis table...
		INSERT INTO dbo.gisLocationDenormalized
			(
				Level1ID, 
				Level2ID, 
				Level3ID, 
				Level4ID, 
				Level5ID, 
				Level6ID, 
				Level7ID,
				Level1Name,
				Level2Name, 
				Level3Name, 
				Level4Name, 
				Level5Name, 
				Level6Name, 
				Level7Name,
				Node,
				Level,
				idfsLocation,
				LevelType,
				idfsLanguage
			)
		SELECT  L1ID,L2ID,L3ID,L4ID,L5ID,L6ID,L7ID,
				L1NAME,L2NAME,L3NAME,L4NAME,L5NAME,L6NAME,L7NAME,
				node,[level],l.idfsLocation,ISNULL(lt.strTextString,[level]),l.LanguageId
		FROM @t l
		JOIN gisBaseReference b ON b.idfsGISBaseReference = l.idfsLocation
		JOIN gisReferenceType t ON t.idfsGISReferenceType = b.idfsGISReferenceType
		JOIN dbo.trtStringNameTranslation lt ON 
		lt.idfsLanguage = l.LanguageId AND lt.idfsBaseReference = 
		CASE l.Node.GetLevel() 
			WHEN 1 THEN 10003001 
			WHEN 2 THEN 10003003
			WHEN 3 THEN 10003002 
			WHEN 4 THEN 10003004 
			WHEN 5 THEN 0
			WHEN 6 THEN 0
			WHEN 7 THEN 0
		ELSE 0 END



	Fini:
		-- Bye!
		RETURN

END
GO
PRINT N'Altering Procedure [dbo].[USP_ADMIN_STAT_SET]...';


GO

--=================================================================================================================
-- Created by:				Joan Li
-- Last modified by:		
-- Joan Li					06/13/17	Created based on V6 spStatistic_Post:  V7 usp54 purpose: save records in tlbStatistic
-- Joan Li	                06/15/17	change action parameter
-- Lamont Mitchell			1/2/19		Added ReturnCode and ReturnMessage and changed @idfStatistic from output parameter added it to the Select output
-- Ricky Moss				3/12/20		Check for Duplicates and return a message and statistic id if record exists.
-- Ricky Moss				3/18/20		Added settlement parameter
-- Ricky Moss				3/23/20		Developed search for existing statistic data
-- LAMONT MITCHELL			6/7/2022	ADDED BULKINPORT PARAMETER TO DISTINGUISH BETWEEN BULK IMPORT AND SINGLE ENTERIES.. BULK IMPORT BYPASSES DUPLICATE CHECK
-- Leo Tracchia				9/6/2022	modified logic to handle duplicate data during bulk import
-- Leo Tracchia				10/26/2022	fix for GAT defect #472, DevOps 5259
--=================================================================================================================

ALTER PROCEDURE [dbo].[USP_ADMIN_STAT_SET]
	(
	 @idfStatistic						BIGINT		= NULL,	--##PARAM @idfStatistic - statistic record ID
	 @idfsStatisticDataType				BIGINT		= NULL,	--##PARAM @idfsStatisticDataType - statistic data Type
	 @idfsMainBaseReference				BIGINT		= NULL,	--##PARAM @idfsMainBaseReference - statistic base reference
 	 @idfsStatisticAreaType				BIGINT		= NULL,	--##PARAM @idfsStatisticAreaType - statistic Area Type
	 @idfsStatisticPeriodType			BIGINT		= NULL,	--##PARAM @idfsStatisticPeriodType - statistic period Type
	 @LocationUserControlidfsCountry	BIGINT		= NULL,	--##PARAM @idfsArea - statistic Area
	 @LocationUserControlidfsRegion		BIGINT		= NULL,	--##PARAM @idfsArea - statistic Area
	 @LocationUserControlidfsRayon 		BIGINT		= NULL,	--##PARAM @idfsArea - statistic Area
	 @LocationUserControlidfsSettlement	BIGINT		= NULL,	--##PARAM @idfsArea - statistic Area
	 @datStatisticStartDate				DATETIME	= NULL,	--##PARAM @datStatisticStartDate - start date
	 @datStatisticFinishDate			DATETIME	= NULL,	--##PARAM @datStatisticFinishDate - finish date 
	 @varValue							INT			= NULL,	--##PARAM @varValue - statistic content
	 @idfsStatisticalAgeGroup			BIGINT		= NULL,
	 @idfsParameterName					BIGINT		= NULL,
	 @bulkImport						Bit			= 0
	)
AS
DECLARE @returnCode					INT = 0 
DECLARE	@returnMsg					NVARCHAR(max) = 'SUCCESS' 
DECLARE @existingStatistic			BIGINT = null;
DECLARE @idfsArea					BIGINT
Declare @SupressSelect table
( 
	retrunCode int,
	returnMessage varchar(200)
)
BEGIN
	BEGIN TRY  	
		BEGIN TRANSACTION

			IF @LocationUserControlidfsSettlement IS NOT NULL
				SELECT @idfsArea = @LocationUserControlidfsSettlement
			ELSE IF @LocationUserControlidfsRayon IS NOT NULL 
				SELECT @idfsArea = @LocationUserControlidfsRayon
			ELSE IF @LocationUserControlidfsRegion IS NOT NULL
				SELECT @idfsArea = @LocationUserControlidfsRegion
			ELSE 
				SELECT @idfsArea = @LocationUserControlidfsCountry

			--SELECT @existingStatistic = (SELECT top 1(idfStatistic) from tlbStatistic WHERE idfsStatisticDataType = @idfsStatisticDataType AND idfsStatisticPeriodType = @idfsStatisticPeriodType AND ((idfsStatisticalAgeGroup = @idfsStatisticalAgeGroup) OR (idfsStatisticalAgeGroup IS NULL AND @idfsStatisticalAgeGroup IS NULL ))AND idfsStatisticAreaType = @idfsStatisticAreaType AND idfsArea = @idfsArea AND datStatisticStartDate = @datStatisticStartDate AND ((idfsMainBaseReference = @idfsMainBaseReference ) OR idfsMainBaseReference IS NULL AND @idfsMainBaseReference IS NULL) )
			--SELECT @existingStatistic =
			--	(SELECT top 1(idfStatistic) 
			--	FROM tlbStatistic 
			--	WHERE 
			--	idfsStatisticDataType = @idfsStatisticDataType 
			--	AND idfsStatisticAreaType = @idfsStatisticAreaType 
			--	AND idfsStatisticPeriodType = @idfsStatisticPeriodType 
			--	AND idfsArea = @idfsArea --Georgia?
			--	AND datStatisticStartDate = @datStatisticStartDate 
			--	AND datStatisticFinishDate = @datStatisticFinishDate 
			--	--AND varValue = @varValue
			--	AND idfsStatisticalAgeGroup = @idfsStatisticalAgeGroup)

			--IF(@existingStatistic IS NOT NULL AND @idfStatistic IS NULL) --AND @bulkImport = 0)
			--	BEGIN
			--		SELECT @returnMsg = 'DOES EXIST'
			--		SELECT @idfStatistic = @existingStatistic
			--	END
			--ELSE 

			-- if @idfStatistic is not passed in... (possibly a new record)
			IF NOT EXISTS (SELECT * FROM dbo.tlbStatistic WHERE  idfStatistic = @idfStatistic) 
				BEGIN

					--print 'getting existing statistic...'

					-- check if a row already exists with the same data
					SELECT @existingStatistic =
						(SELECT top 1(idfStatistic) 
						FROM tlbStatistic 
						WHERE 
						(idfsStatisticDataType = @idfsStatisticDataType or @idfsStatisticDataType is null)
						AND (idfsMainBaseReference = @idfsMainBaseReference or @idfsMainBaseReference is null)
						AND (idfsStatisticAreaType = @idfsStatisticAreaType or @idfsStatisticAreaType is null)
						AND (idfsStatisticPeriodType = @idfsStatisticPeriodType or @idfsStatisticPeriodType is null)
						AND (idfsArea = @idfsArea or @idfsArea is null)
						AND (datStatisticStartDate = @datStatisticStartDate or @datStatisticStartDate is null)
						AND (datStatisticFinishDate = @datStatisticFinishDate or @datStatisticFinishDate is null)
						--AND (varValue = @varValue or @varValue is null)
						AND (idfsStatisticalAgeGroup = @idfsStatisticalAgeGroup or @idfsStatisticalAgeGroup is null)
						AND intRowStatus = 0)

					print @existingStatistic

					-- if row doesn't exists, then insert new data
					IF(@existingStatistic IS NULL)
						BEGIN

							--print 'existing statistic is null, so insert'

							INSERT INTO @SupressSelect
							EXEC dbo.USP_GBL_NEXTKEYID_GET 'tlbStatistic', @idfStatistic OUTPUT

							INSERT INTO tlbStatistic
								(
									idfStatistic,
									idfsStatisticDataType,
									idfsMainBaseReference,
									idfsStatisticAreaType,
									idfsStatisticPeriodType,
									idfsArea,
									datStatisticStartDate,
									datStatisticFinishDate,
									varValue,
									idfsStatisticalAgeGroup
								)
							VALUES
								(
									@idfStatistic,
									@idfsStatisticDataType,
									@idfsMainBaseReference,
									@idfsStatisticAreaType,
									@idfsStatisticPeriodType,
									CASE ISNULL(@LocationUserControlidfsSettlement , '') 
									WHEN '' THEN
										CASE ISNULL(@LocationUserControlidfsRayon, '') 
										WHEN '' THEN
											CASE ISNULL(@LocationUserControlidfsRegion,'')
												WHEN '' THEN
													@LocationUserControlidfsCountry 
												ELSE 
													@LocationUserControlidfsRegion
												END
										ELSE 
												@LocationUserControlidfsRayon 
										END 
									ELSE 
										@LocationUserControlidfsSettlement  
									END,
									@datStatisticStartDate,
									@datStatisticFinishDate,
									CAST(@varValue AS INT),
									@idfsStatisticalAgeGroup
								)
						END
					-- else, just update it with @existingStatistic
					ELSE

						--print 'existing statistic is NOT null, so update'

						UPDATE	tlbStatistic
						SET		idfsStatisticDataType = @idfsStatisticDataType,
								idfsMainBaseReference = @idfsMainBaseReference,
								idfsStatisticAreaType = @idfsStatisticAreaType,
								idfsStatisticPeriodType = @idfsStatisticPeriodType,
								idfsArea = CASE ISNULL(@LocationUserControlidfsSettlement , '') 
									WHEN '' THEN
										CASE ISNULL(@LocationUserControlidfsRayon, '') 
										WHEN '' THEN
											CASE ISNULL(@LocationUserControlidfsRegion,'')
												WHEN '' THEN
													@LocationUserControlidfsCountry 
												ELSE 
													@LocationUserControlidfsRegion
												END
										ELSE 
												@LocationUserControlidfsRayon 
										END 
									ELSE 
										@LocationUserControlidfsSettlement  
									END,
								datStatisticStartDate = @datStatisticStartDate,
								datStatisticFinishDate = @datStatisticFinishDate,
								varValue = CAST(@varValue AS INT),
								idfsStatisticalAgeGroup = @idfsStatisticalAgeGroup
						 WHERE 	idfStatistic = @existingStatistic

				END

			-- update record with the passed in @idfStatistic (does not happen during bulk import)
			ELSE 

				--print '@idfStatistic was passed in (does not happen during bulk import)'

				UPDATE	tlbStatistic
				SET		idfsStatisticDataType = @idfsStatisticDataType,
						idfsMainBaseReference = @idfsMainBaseReference,
						idfsStatisticAreaType = @idfsStatisticAreaType,
						idfsStatisticPeriodType = @idfsStatisticPeriodType,
						idfsArea = CASE ISNULL(@LocationUserControlidfsSettlement , '') 
							WHEN '' THEN
								CASE ISNULL(@LocationUserControlidfsRayon, '') 
								WHEN '' THEN
									CASE ISNULL(@LocationUserControlidfsRegion,'')
										WHEN '' THEN
											@LocationUserControlidfsCountry 
										ELSE 
											@LocationUserControlidfsRegion
										END
								ELSE 
										@LocationUserControlidfsRayon 
								END 
							ELSE 
								@LocationUserControlidfsSettlement  
							END,
						datStatisticStartDate = @datStatisticStartDate,
						datStatisticFinishDate = @datStatisticFinishDate,
						varValue = CAST(@varValue AS INT),
						idfsStatisticalAgeGroup = @idfsStatisticalAgeGroup
				 WHERE 	idfStatistic = @idfStatistic

		-- Commit the transaction
		IF @@TRANCOUNT > 0
			COMMIT  
		
		Select @returnCode 'ReturnCode', @returnMsg 'ReturnMessage' , @idfStatistic 'idfStatistic'
	END TRY  

	BEGIN CATCH  

		-- Execute error retrieval routine. 
		IF @@TRANCOUNT > 0
			BEGIN
				ROLLBACK


			END;
			Throw;		
	END CATCH; 
END
GO
PRINT N'Altering Procedure [dbo].[USP_REF_BASEREFERENCE_DEL]...';


GO
-- ================================================================================================
-- Name: USP_REF_BASEREFERENCE_DEL
-- Description:	Removes a base reference
--                      
-- Author: Ricky Moss
-- Revision History:
-- Name             Date       Change Detail
-- ---------------- ---------- -------------------------------------------------------------------
-- Ricky Moss		02/10/2019 Initial release.
-- Ricky Moss		02/12/2019 Returns values.
-- LAMONT MITCHELL	06/17/2021 PROHIBITED DELETION FOR REFERENCE TYPES THAT ARE FOUND BASED ON 
--                             USE CASE DOCUMENT SAUC40
-- Stephen Long     10/26/2022 Added site alert for reference table change event.
--
-- exec USP_REF_BASEREFERENCE_DEL 55540680000289
-- ================================================================================================
ALTER PROCEDURE [dbo].[USP_REF_BASEREFERENCE_DEL]
(
    @idfsBaseReference BIGINT,
    @EventTypeId BIGINT,
    @SiteId BIGINT,
    @UserId BIGINT,
    @LocationId BIGINT,
    @AuditUserName NVARCHAR(200)
)
AS
BEGIN
    BEGIN TRY
        DECLARE @ReturnMessage NVARCHAR(MAX) = 'SUCCESS',
                @ReturnCode BIGINT = 0, 
                @Duplicate BIT = 0;
        DECLARE @SuppressSelect TABLE
        (
            ReturnCode INT,
            ReturnMessage NVARCHAR(MAX)
        );

        SELECT @Duplicate =
        (
            SELECT Top (1)
                Case
                    WHEN rt.idfsReferenceType = 19000001 THEN
                        1
                    WHEN rt.idfsReferenceType = 19000003 THEN
                        1
                    WHEN rt.idfsReferenceType = 19000004 THEN
                        1
                    WHEN rt.idfsReferenceType = 19000007 THEN
                        1
                    WHEN rt.idfsReferenceType = 19000012 THEN
                        1
                    WHEN rt.idfsReferenceType = 19000013 THEN
                        1
                    WHEN rt.idfsReferenceType = 19000015 THEN
                        1
                    WHEN rt.idfsReferenceType = 19000016 THEN
                        1
                    WHEN rt.idfsReferenceType = 19000017 THEN
                        1
                    WHEN rt.idfsReferenceType = 19000018 THEN
                        1
                    WHEN rt.idfsReferenceType = 19000020 THEN
                        1
                    WHEN rt.idfsReferenceType = 19000023 THEN
                        1
                    WHEN rt.idfsReferenceType = 19000025 THEN
                        1
                    WHEN rt.idfsReferenceType = 19000028 THEN
                        1
                    WHEN rt.idfsReferenceType = 19000030 THEN
                        1
                    WHEN rt.idfsReferenceType = 19000031 THEN
                        1
                    WHEN rt.idfsReferenceType = 19000034 THEN
                        1
                    WHEN rt.idfsReferenceType = 19000036 THEN
                        1
                    WHEN rt.idfsReferenceType = 19000039 THEN
                        1
                    WHEN rt.idfsReferenceType = 19000040 THEN
                        1
                    WHEN rt.idfsReferenceType = 19000041 THEN
                        1
                    WHEN rt.idfsReferenceType = 19000042 THEN
                        1
                    WHEN rt.idfsReferenceType = 19000043 THEN
                        1
                    WHEN rt.idfsReferenceType = 19000049 THEN
                        1
                    WHEN rt.idfsReferenceType = 19000057 THEN
                        1
                    WHEN rt.idfsReferenceType = 19000059 THEN
                        1
                    WHEN rt.idfsReferenceType = 19000063 THEN
                        1
                    WHEN rt.idfsReferenceType = 19000067 THEN
                        1
                    WHEN rt.idfsReferenceType = 19000068 THEN
                        1
                    WHEN rt.idfsReferenceType = 19000076 THEN
                        1
                    WHEN rt.idfsReferenceType = 19000080 THEN
                        1
                    WHEN rt.idfsReferenceType = 19000081 THEN
                        1
                    WHEN rt.idfsReferenceType = 19000082 THEN
                        1
                    WHEN rt.idfsReferenceType = 19000085 THEN
                        1
                    WHEN rt.idfsReferenceType = 19000089 THEN
                        1
                    WHEN rt.idfsReferenceType = 19000091 THEN
                        1
                    WHEN rt.idfsReferenceType = 19000093 THEN
                        1
                    WHEN rt.idfsReferenceType = 19000094 THEN
                        1
                    WHEN rt.idfsReferenceType = 19000095 THEN
                        1
                    WHEN rt.idfsReferenceType = 19000100 THEN
                        1
                    WHEN rt.idfsReferenceType = 19000102 THEN
                        1
                    WHEN rt.idfsReferenceType = 19000103 THEN
                        1
                    WHEN rt.idfsReferenceType = 19000106 THEN
                        1
                    WHEN rt.idfsReferenceType = 19000108 THEN
                        1
                    WHEN rt.idfsReferenceType = 19000110 THEN
                        1
                    WHEN rt.idfsReferenceType = 19000111 THEN
                        1
                    WHEN rt.idfsReferenceType = 19000112 THEN
                        1
                    WHEN rt.idfsReferenceType = 19000113 THEN
                        1
                    WHEN rt.idfsReferenceType = 19000114 THEN
                        1
                    WHEN rt.idfsReferenceType = 19000115 THEN
                        1
                    WHEN rt.idfsReferenceType = 19000117 THEN
                        1
                    WHEN rt.idfsReferenceType = 19000128 THEN
                        1
                    WHEN rt.idfsReferenceType = 19000129 THEN
                        1
                    WHEN rt.idfsReferenceType = 19000133 THEN
                        1
                    WHEN rt.idfsReferenceType = 19000151 THEN
                        1
                    WHEN rt.idfsReferenceType = 19000155 THEN
                        1
                    WHEN rt.idfsReferenceType = 19000158 THEN
                        1
                    WHEN rt.idfsReferenceType = 19000160 THEN
                        1
                    WHEN rt.idfsReferenceType = 19000163 THEN
                        1
                    WHEN rt.idfsReferenceType = 19000504 THEN
                        1
                    WHEN rt.idfsReferenceType = 19000512 THEN
                        1
                    WHEN rt.idfsReferenceType = 19000513 THEN
                        1
                    WHEN rt.idfsReferenceType = 19000514 THEN
                        1
                    WHEN rt.idfsReferenceType = 19000526 THEN
                        1
                    WHEN rt.idfsReferenceType = 19000527 THEN
                        1
                    WHEN rt.idfsReferenceType IS NULL THEN
                        0
                    ELSE
                        0
                END
            FROM dbo.trtReferenceType rt
                JOIN dbo.trtBaseReference br
                    ON rt.idfsReferenceType = br.idfsReferenceType
            WHERE br.idfsBaseReference = @idfsBaseReference
        )

        IF @Duplicate = 0
        BEGIN
            UPDATE dbo.trtBaseReference
            SET intRowStatus = 1, 
                AuditUpdateUser = @AuditUserName, 
                AuditUpdateDTM = GETDATE()
            WHERE idfsBaseReference = @idfsBaseReference;

            UPDATE dbo.trtStringNameTranslation
            SET intRowStatus = 1, 
                AuditUpdateUser = @AuditUserName, 
                AuditUpdateDTM = GETDATE()
            WHERE idfsBaseReference = @idfsBaseReference;

            INSERT INTO @SuppressSelect
            EXECUTE dbo.USP_ADMIN_EVENT_SET-1,
                                           @EventTypeId,
                                           @UserId,
                                           @idfsBaseReference,
                                           NULL,
                                           @SiteId,
                                           NULL,
                                           @SiteId,
                                           @LocationId,
                                           @AuditUserName;
        END
        ELSE
        BEGIN
            SELECT @ReturnMessage = 'CAN NOT DELETE';
        END
        SELECT @ReturnCode 'ReturnCode',
               @ReturnMessage 'ReturnMessage';
    END TRY
    BEGIN CATCH
        THROW;
    END CATCH
END
GO
PRINT N'Update complete.';


GO
